<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>テーブル編集</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 10px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        button {
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        .editable {
            min-width: 50px;
            min-height: 20px;
            white-space: pre-wrap; /* 改行を表示するために追加 */
        }
        
        /* 選択されたセルのスタイル */
        .cell-selected {
            background-color: rgba(75, 123, 236, 0.2);
            border: 1px solid rgba(75, 123, 236, 0.8);
        }
        
        /* 選択範囲のスタイル */
        .selection-area {
            position: absolute;
            background-color: rgba(75, 123, 236, 0.1);
            border: 1px solid rgba(75, 123, 236, 0.5);
            pointer-events: none;
            z-index: 99;
        }
        
        /* テーブル下端と右端の追加エリア */
        .table-container {
            position: relative;
            display: inline-block;
        }
        
        .add-row-zone {
            height: 20px;
            background-color: #f9f9f9;
            border: 1px dashed #ccc;
            margin-top: -10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: ns-resize; /* 上下のリサイズカーソル */
            color: #666;
            position: relative;
        }
        
        .add-column-zone {
            width: 20px;
            background-color: #f9f9f9;
            border: 1px dashed #ccc;
            position: absolute;
            top: 0;
            right: -20px;
            bottom: 20px; /* 行追加ゾーンの高さ分調整 */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: ew-resize; /* 左右のリサイズカーソル */
            color: #666;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        
        .add-row-zone:hover, .add-column-zone:hover {
            background-color: #e9e9e9;
            color: #333;
        }
        
        /* ドラッグ中のプレビュー */
        .drag-preview {
            position: absolute;
            background-color: rgba(75, 123, 236, 0.2);
            border: 1px dashed rgba(75, 123, 236, 0.5);
            pointer-events: none;
            z-index: 100;
        }
        
        .drag-preview.delete {
            background-color: rgba(236, 75, 75, 0.2);
            border: 1px dashed rgba(236, 75, 75, 0.5);
        }
        
        .drag-preview-text {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 101;
        }
        
        .drag-preview-text.delete {
            color: #d9534f;
        }
        
        /* Undoボタン */
        .undo-button {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            color: #333;
        }
        
        .undo-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
    </style>
    <!-- React, ReactDOM, Babel CDNを追加 -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <!-- テーブルデータをグローバル変数として定義 -->
    <script>
        const initialTableData = TABLE_DATA_PLACEHOLDER;
    </script>

    <!-- テーブルエディタのReactコード -->
    <script type="text/babel">
        // VSCodeのWebviewオブジェクト
        const vscode = acquireVsCodeApi();

        // テーブルエディタコンポーネント
        const TableEditor = () => {
            const [tableData, setTableData] = React.useState(initialTableData);
            const [history, setHistory] = React.useState([]);
            const [selectedCells, setSelectedCells] = React.useState([]);
            const [selectionStart, setSelectionStart] = React.useState(null);
            const [selectionArea, setSelectionArea] = React.useState(null);
            const [dragState, setDragState] = React.useState({
                isDragging: false,
                type: null, // 'row' または 'column'
                startY: 0,
                startX: 0,
                currentY: 0,
                currentX: 0,
                rowCount: 0,
                columnCount: 0,
                isDelete: false
            });
            
            // 最新の選択状態を参照するためのref
            const selectedCellsRef = React.useRef(selectedCells);
            
            // selectedCellsが更新されたらrefも更新
            React.useEffect(() => {
                selectedCellsRef.current = selectedCells;
            }, [selectedCells]);
            
            // 最新のドラッグ状態を参照するためのref
            const dragStateRef = React.useRef(dragState);
            
            // dragStateが更新されたらrefも更新
            React.useEffect(() => {
                dragStateRef.current = dragState;
            }, [dragState]);
            
            const tableContainerRef = React.useRef(null);
            const rowZoneRef = React.useRef(null);
            const columnZoneRef = React.useRef(null);
            const tableRef = React.useRef(null);
            
            // 履歴に現在の状態を追加
            const addToHistory = (action) => {
                console.log('履歴に追加:', action);
                // ディープコピーを作成
                const currentState = JSON.parse(JSON.stringify(tableData));
                setHistory([...history, { state: currentState, action }]);
            };
            
            // 元に戻す
            const undo = () => {
                if (history.length === 0) return;
                
                const lastHistoryItem = history[history.length - 1];
                console.log('元に戻します:', lastHistoryItem.action);
                
                // 履歴から最後の状態を取得
                setTableData(lastHistoryItem.state);
                
                // 履歴から最後の項目を削除
                setHistory(history.slice(0, -1));
            };

            // 行を追加
            const addRows = (count = 1) => {
                console.log(`${count}行追加します`);
                
                // 現在の状態を履歴に追加
                addToHistory(`${count}行追加`);
                
                const newRows = [];
                for (let i = 0; i < count; i++) {
                    newRows.push(Array(tableData.headers.length).fill(''));
                }
                
                setTableData({
                    ...tableData,
                    rows: [...tableData.rows, ...newRows]
                });
            };

            // 列を追加
            const addColumns = (count = 1) => {
                console.log(`${count}列追加します`);
                
                // 現在の状態を履歴に追加
                addToHistory(`${count}列追加`);
                
                const newHeaders = [];
                for (let i = 0; i < count; i++) {
                    newHeaders.push('新しい列');
                }
                
                setTableData({
                    ...tableData,
                    headers: [...tableData.headers, ...newHeaders],
                    rows: tableData.rows.map(row => [...row, ...Array(count).fill('')])
                });
            };
            
            // 行を削除
            const deleteRows = (count = 1) => {
                console.log(`${count}行削除します`);
                
                if (tableData.rows.length <= count) {
                    console.log('削除できる行がありません（最低1行は必要）');
                    return;
                }
                
                // 現在の状態を履歴に追加
                addToHistory(`${count}行削除`);
                
                const newRows = [...tableData.rows];
                newRows.splice(-count); // 末尾からcount行を削除
                
                setTableData({
                    ...tableData,
                    rows: newRows
                });
            };
            
            // 列を削除
            const deleteColumns = (count = 1) => {
                console.log(`${count}列削除します`);
                
                if (tableData.headers.length <= count) {
                    console.log('削除できる列がありません（最低1列は必要）');
                    return;
                }
                
                // 現在の状態を履歴に追加
                addToHistory(`${count}列削除`);
                
                const newHeaders = [...tableData.headers];
                newHeaders.splice(-count); // 末尾からcount列を削除
                
                const newRows = tableData.rows.map(row => {
                    const newRow = [...row];
                    newRow.splice(-count); // 末尾からcount列を削除
                    return newRow;
                });
                
                setTableData({
                    ...tableData,
                    headers: newHeaders,
                    rows: newRows
                });
            };
            
            // テーブルを保存
            const saveTable = () => {
                try {
                    // 編集されたテーブルデータを収集
                    const headers = Array.from(document.querySelectorAll('th .editable')).map(th => {
                        // 改行を<br>タグに変換して保存
                        return th.innerHTML.replace(/<div>/g, '<br>').replace(/<\/div>/g, '');
                    });
                    
                    const rows = [];
                    const rowElements = document.querySelectorAll('tbody tr');
                    rowElements.forEach(row => {
                        const cells = Array.from(row.querySelectorAll('td .editable')).map(td => {
                            // 改行を<br>タグに変換して保存
                            return td.innerHTML.replace(/<div>/g, '<br>').replace(/<\/div>/g, '').replace(/<br>/g, '<br>');
                        });
                        rows.push(cells);
                    });
                    
                    // 列数を統一する
                    const maxColumns = Math.max(
                        headers.length,
                        ...rows.map(row => row.length)
                    );
                    
                    // ヘッダーの列数を調整
                    while (headers.length < maxColumns) {
                        headers.push('');
                    }
                    
                    // 各行の列数を調整
                    rows.forEach(row => {
                        while (row.length < maxColumns) {
                            row.push('');
                        }
                    });
                    
                    // 更新されたテーブルデータ
                    const updatedTableData = {
                        startLine: tableData.startLine,
                        endLine: tableData.endLine,
                        headers,
                        rows
                    };
                    
                    console.log('テーブルを保存します', {
                        headers: headers.length,
                        rows: rows.length
                    });
                    
                    // VSCodeに更新を通知
                    vscode.postMessage({
                        command: 'updateTable',
                        tableData: updatedTableData
                    });
                } catch (error) {
                    console.log('テーブル保存中にエラーが発生しました', error.message);
                    console.error('Error saving table:', error);
                }
            };

            // 編集可能なセルコンポーネント
            const EditableCell = ({ content, rowIndex, colIndex }) => {
                // <br>タグを実際の改行に変換して表示
                const htmlContent = content.replace(/<br>/g, '\\n').replace(/\\n/g, '<br>');
                
                // このセルが選択されているかチェック
                const isSelected = selectedCells.some(cell => 
                    cell.row === rowIndex && cell.col === colIndex
                );
                
                // 選択されたセルへの参照
                const cellRef = React.useRef(null);
                
                // 単一選択かどうかをチェック
                const isSingleSelection = selectedCells.length === 1 && isSelected;
                
                // 最後の有効な内容を保持するためのref
                const lastValidContentRef = React.useRef(htmlContent);
                
                // 編集モードかどうかを追跡するstate
                const [isEditing, setIsEditing] = React.useState(false);
                
                // クリックイベントハンドラ
                const handleClick = (e) => {
                    // 右クリックの場合は処理しない
                    if (e.button === 2) return;
                    
                    // 単一選択の場合は、編集モードを優先
                    if (isSingleSelection && !e.ctrlKey && !e.shiftKey) {
                        setIsEditing(true);
                        // クリックイベントをそのまま通過させる（編集のため）
                        return;
                    }
                    
                    // それ以外の場合は選択処理を行う
                    handleCellMouseDown(e, rowIndex, colIndex);
                };
                
                // フォーカスイベントハンドラ
                const handleFocus = (e) => {
                    // 単一選択の場合は編集モードに
                    if (isSingleSelection) {
                        setIsEditing(true);
                    }
                };
                
                // ブラーイベントハンドラ
                const handleBlur = (e) => {
                    // 編集モードを終了
                    setIsEditing(false);
                    
                    // 内容が変更されていれば保存
                    if (cellRef.current && cellRef.current.innerHTML !== lastValidContentRef.current) {
                        updateCellContent(rowIndex, colIndex, cellRef.current.innerHTML);
                        lastValidContentRef.current = cellRef.current.innerHTML;
                    }
                };
                
                // キーダウンイベントハンドラ
                const handleKeyDown = (e) => {
                    // Enterキーが押されたとき（Shiftキーなしの場合）
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        e.target.blur(); // フォーカスを外す
                        return;
                    }
                    
                    // Escキーが押されたとき
                    if (e.key === 'Escape') {
                        // 元の内容に戻す
                        if (cellRef.current) {
                            cellRef.current.innerHTML = lastValidContentRef.current;
                        }
                        e.target.blur(); // フォーカスを外す
                        return;
                    }
                };
                
                // 入力イベントハンドラ
                const handleInput = (e) => {
                    // 入力内容を保存（遅延なし）
                    if (cellRef.current) {
                        const newContent = cellRef.current.innerHTML;
                        // 内容が変更された場合のみ更新
                        if (newContent !== lastValidContentRef.current) {
                            updateCellContent(rowIndex, colIndex, newContent);
                            lastValidContentRef.current = newContent;
                        }
                    }
                };
                
                // マウント時とアンマウント時の処理
                React.useEffect(() => {
                    // 内容が変更されたら参照を更新
                    lastValidContentRef.current = htmlContent;
                    
                    // コンポーネントがアンマウントされるときのクリーンアップ
                    return () => {
                        // 必要に応じてクリーンアップ処理を追加
                    };
                }, [htmlContent]);
                
                // 編集モードが変わったときの処理
                React.useEffect(() => {
                    const cellElement = cellRef.current;
                    if (!cellElement) return;
                    
                    if (isEditing) {
                        // 編集モードになったらフォーカスを設定
                        cellElement.focus();
                        
                        // カーソルを末尾に移動
                        const range = document.createRange();
                        const sel = window.getSelection();
                        
                        try {
                            // テキストノードがある場合は最後のテキストノードの末尾にカーソルを置く
                            if (cellElement.lastChild && cellElement.lastChild.nodeType === Node.TEXT_NODE) {
                                range.setStart(cellElement.lastChild, cellElement.lastChild.length);
                                range.collapse(true);
                                sel.removeAllRanges();
                                sel.addRange(range);
                            } else {
                                // テキストノードがない場合は要素の末尾にカーソルを置く
                                range.selectNodeContents(cellElement);
                                range.collapse(false);
                                sel.removeAllRanges();
                                sel.addRange(range);
                            }
                        } catch (e) {
                            console.error('カーソル位置の設定に失敗しました', e);
                        }
                    }
                }, [isEditing]);
                
                return (
                    <div
                        ref={cellRef}
                        className={`editable ${isSelected ? 'cell-selected' : ''}`}
                        contentEditable="true"
                        dangerouslySetInnerHTML={{ __html: htmlContent }}
                        onClick={handleClick}
                        onMouseDown={(e) => {
                            // 単一選択の場合は、編集モードを優先
                            if (isSingleSelection && !e.ctrlKey && !e.shiftKey) {
                                // イベントをそのまま通過させる（編集のため）
                                return;
                            }
                            
                            // それ以外の場合は選択処理を行う
                            handleCellMouseDown(e, rowIndex, colIndex);
                        }}
                        onMouseEnter={(e) => handleCellMouseEnter(e, rowIndex, colIndex)}
                        onFocus={handleFocus}
                        onBlur={handleBlur}
                        onKeyDown={handleKeyDown}
                        onInput={handleInput}
                        style={{ 
                            position: 'relative',
                            // 単一選択または編集モードの場合は通常のカーソルを表示
                            cursor: (isSingleSelection || isEditing) ? 'text' : 'default'
                        }}
                    />
                );
            };
            
            // セルの内容を更新する関数
            const updateCellContent = (rowIndex, colIndex, newContent) => {
                // ヘッダー行の場合
                if (rowIndex === -1) {
                    setTableData(prevData => {
                        const newHeaders = [...prevData.headers];
                        newHeaders[colIndex] = newContent;
                        
                        return {
                            ...prevData,
                            headers: newHeaders
                        };
                    });
                } 
                // 通常の行の場合
                else if (rowIndex >= 0) {
                    setTableData(prevData => {
                        const newRows = [...prevData.rows];
                        
                        // 行と列が範囲内かチェック
                        if (rowIndex < newRows.length && colIndex < prevData.headers.length) {
                            // 行のディープコピーを作成
                            newRows[rowIndex] = [...newRows[rowIndex]];
                            newRows[rowIndex][colIndex] = newContent;
                        }
                        
                        return {
                            ...prevData,
                            rows: newRows
                        };
                    });
                }
            };
            
            // セルのマウスダウンハンドラ
            const handleCellMouseDown = (e, rowIndex, colIndex) => {
                // テキスト選択やカーソル位置決めの場合は、イベントを処理しない
                if (e.target.isContentEditable && 
                    (window.getSelection().toString() || 
                     e.target !== e.currentTarget || 
                     e.target.tagName === 'BR')) {
                    return;
                }
                
                // 右クリックの場合は処理しない
                if (e.button === 2) {
                    return;
                }
                
                // 単一選択されたセルをクリックした場合は、編集モードを優先
                const isSingleSelectedCell = selectedCells.length === 1 && 
                    selectedCells[0].row === rowIndex && 
                    selectedCells[0].col === colIndex;
                
                if (isSingleSelectedCell && !e.ctrlKey && !e.shiftKey) {
                    // イベントをそのまま通過させる（編集のため）
                    return;
                }
                
                // 以降は選択処理
                e.preventDefault();
                
                // Shiftキーが押されている場合は範囲選択
                if (e.shiftKey && selectedCells.length > 0) {
                    // 最後に選択されたセルを基準にする
                    const lastCell = selectedCells[selectedCells.length - 1];
                    
                    // 選択範囲を計算
                    const startRow = Math.min(lastCell.row, rowIndex);
                    const endRow = Math.max(lastCell.row, rowIndex);
                    const startCol = Math.min(lastCell.col, colIndex);
                    const endCol = Math.max(lastCell.col, colIndex);
                    
                    // 選択範囲内のすべてのセルを選択
                    const newSelection = [];
                    for (let r = startRow; r <= endRow; r++) {
                        for (let c = startCol; c <= endCol; c++) {
                            newSelection.push({ row: r, col: c });
                        }
                    }
                    
                    setSelectedCells(newSelection);
                    return;
                }
                
                // Ctrlキーが押されていない場合は選択をクリア
                if (!e.ctrlKey) {
                    setSelectedCells([]);
                }
                
                // 選択開始位置を設定
                setSelectionStart({ 
                    row: rowIndex, 
                    col: colIndex,
                    clientX: e.clientX,
                    clientY: e.clientY
                });
                
                // このセルを選択に追加
                const newSelection = e.ctrlKey ? [...selectedCells] : [];
                
                // 既に選択されている場合は選択解除
                const alreadySelected = newSelection.some(
                    cell => cell.row === rowIndex && cell.col === colIndex
                );
                
                if (alreadySelected) {
                    setSelectedCells(newSelection.filter(
                        cell => !(cell.row === rowIndex && cell.col === colIndex)
                    ));
                } else {
                    setSelectedCells([...newSelection, { row: rowIndex, col: colIndex }]);
                }
                
                // グローバルのマウスイベントを追加
                document.addEventListener('mousemove', handleCellMouseMove);
                document.addEventListener('mouseup', handleCellMouseUp);
            };
            
            // セルのマウス移動ハンドラ
            const handleCellMouseMove = (e) => {
                if (!selectionStart) return;
                
                // 移動距離が小さい場合は、ドラッグとみなさない（クリックの精度向上）
                const moveDistance = Math.sqrt(
                    Math.pow(e.clientX - selectionStart.clientX, 2) + 
                    Math.pow(e.clientY - selectionStart.clientY, 2)
                );
                
                if (moveDistance < 5) return;
                
                // 選択範囲の表示を更新
                setSelectionArea({
                    left: Math.min(selectionStart.clientX, e.clientX),
                    top: Math.min(selectionStart.clientY, e.clientY),
                    width: Math.abs(e.clientX - selectionStart.clientX),
                    height: Math.abs(e.clientY - selectionStart.clientY)
                });
            };
            
            // セルのマウスエンターハンドラ（ドラッグ選択用）
            const handleCellMouseEnter = (e, rowIndex, colIndex) => {
                if (!selectionStart) return;
                
                // 選択範囲を計算
                const startRow = Math.min(selectionStart.row, rowIndex);
                const endRow = Math.max(selectionStart.row, rowIndex);
                const startCol = Math.min(selectionStart.col, colIndex);
                const endCol = Math.max(selectionStart.col, colIndex);
                
                // 選択範囲内のすべてのセルを選択
                const newSelection = [];
                for (let r = startRow; r <= endRow; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        newSelection.push({ row: r, col: c });
                    }
                }
                
                setSelectedCells(newSelection);
            };
            
            // セルのマウスアップハンドラ
            const handleCellMouseUp = (e) => {
                // 選択終了
                setSelectionStart(null);
                setSelectionArea(null);
                
                // グローバルのマウスイベントを削除
                document.removeEventListener('mousemove', handleCellMouseMove);
                document.removeEventListener('mouseup', handleCellMouseUp);
                
                console.log('セル選択完了', { selectedCells: selectedCellsRef.current });
            };
            
            // 選択されたセルの内容をコピー
            const copySelectedCells = () => {
                if (selectedCells.length === 0) return;
                
                // 選択されたセルの行と列の範囲を取得
                const rows = selectedCells.map(cell => cell.row);
                const cols = selectedCells.map(cell => cell.col);
                const minRow = Math.min(...rows);
                const maxRow = Math.max(...rows);
                const minCol = Math.min(...cols);
                const maxCol = Math.max(...cols);
                
                // 選択範囲のデータを2次元配列として取得
                const data = [];
                for (let r = minRow; r <= maxRow; r++) {
                    const rowData = [];
                    for (let c = minCol; c <= maxCol; c++) {
                        // ヘッダー行の場合
                        if (r === -1) {
                            rowData.push(tableData.headers[c] || '');
                        } else {
                            // 通常の行の場合
                            rowData.push((tableData.rows[r] && tableData.rows[r][c]) || '');
                        }
                    }
                    data.push(rowData);
                }
                
                // タブ区切りのテキストに変換
                const text = data.map(row => row.join('\t')).join('\n');
                
                // クリップボードにコピー
                navigator.clipboard.writeText(text)
                    .then(() => {
                        console.log('選択されたセルをコピーしました', { rows: data.length, cols: data[0].length });
                    })
                    .catch(err => {
                        console.log('コピーに失敗しました', err);
                    });
            };
            
            // キーボードイベントハンドラ
            React.useEffect(() => {
                const handleKeyDown = (e) => {
                    // 編集中の場合は処理しない
                    if (e.target.isContentEditable && 
                        document.activeElement === e.target && 
                        !e.ctrlKey && 
                        !e.metaKey && 
                        e.key !== 'Escape') {
                        return;
                    }
                    
                    // Ctrl+C でコピー
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        copySelectedCells();
                    }
                    
                    // Escキーで選択解除
                    if (e.key === 'Escape') {
                        setSelectedCells([]);
                    }
                };
                
                document.addEventListener('keydown', handleKeyDown);
                return () => {
                    document.removeEventListener('keydown', handleKeyDown);
                };
            }, [selectedCells]);
            
            // ドラッグ開始ハンドラ
            const handleDragStart = (e, type) => {
                e.preventDefault();
                
                const startY = e.clientY;
                const startX = e.clientX;
                
                console.log('ドラッグを開始しました', { type, startX, startY });
                
                setDragState({
                    isDragging: true,
                    type,
                    startY,
                    startX,
                    currentY: startY,
                    currentX: startX,
                    rowCount: 0,
                    columnCount: 0,
                    isDelete: false
                });
                
                // グローバルのマウスイベントを追加
                document.addEventListener('mousemove', handleDragMove);
                document.addEventListener('mouseup', handleDragEnd);
            };
            
            // ドラッグ移動ハンドラ
            const handleDragMove = (e) => {
                if (!dragStateRef.current.isDragging) return;
                
                const currentY = e.clientY;
                const currentX = e.clientX;
                
                // 行数または列数を計算
                let rowCount = 0;
                let columnCount = 0;
                let isDelete = false;
                
                if (dragStateRef.current.type === 'row') {
                    // マイナス方向（上方向）のドラッグは削除モード
                    isDelete = currentY < dragStateRef.current.startY;
                    
                    if (isDelete) {
                        // 削除する行数を計算（上方向へのドラッグ）
                        rowCount = Math.min(
                            tableData.rows.length - 1, // 最低1行は残す
                            Math.max(1, Math.floor((dragStateRef.current.startY - currentY) / 30))
                        );
                    } else {
                        // 追加する行数を計算（下方向へのドラッグ）
                        rowCount = Math.max(1, Math.floor((currentY - dragStateRef.current.startY) / 30));
                    }
                } else if (dragStateRef.current.type === 'column') {
                    // マイナス方向（左方向）のドラッグは削除モード
                    isDelete = currentX < dragStateRef.current.startX;
                    
                    if (isDelete) {
                        // 削除する列数を計算（左方向へのドラッグ）
                        columnCount = Math.min(
                            tableData.headers.length - 1, // 最低1列は残す
                            Math.max(1, Math.floor((dragStateRef.current.startX - currentX) / 30))
                        );
                    } else {
                        // 追加する列数を計算（右方向へのドラッグ）
                        columnCount = Math.max(1, Math.floor((currentX - dragStateRef.current.startX) / 30));
                    }
                }
                
                // 値が変わった場合のみデバッグログを出力
                if (rowCount !== dragStateRef.current.rowCount || 
                    columnCount !== dragStateRef.current.columnCount ||
                    isDelete !== dragStateRef.current.isDelete) {
                    console.log('ドラッグ中', { 
                        type: dragStateRef.current.type, 
                        rowCount, 
                        columnCount,
                        isDelete,
                        currentX,
                        currentY
                    });
                }
                
                setDragState({
                    ...dragStateRef.current,
                    currentY,
                    currentX,
                    rowCount,
                    columnCount,
                    isDelete
                });
            };
            
            // ドラッグ終了ハンドラ
            const handleDragEnd = (e) => {
                // 現在のドラッグ状態を取得
                const currentDragState = dragStateRef.current;
                
                if (!currentDragState.isDragging) return;
                
                console.log('ドラッグを終了しました', {
                    type: currentDragState.type,
                    rowCount: currentDragState.rowCount,
                    columnCount: currentDragState.columnCount,
                    isDelete: currentDragState.isDelete,
                    currentX: currentDragState.currentX,
                    currentY: currentDragState.currentY
                });
                
                // 行または列を追加/削除
                if (currentDragState.type === 'row') {
                    if (currentDragState.isDelete) {
                        // 行を削除
                        if (currentDragState.rowCount > 0) {
                            deleteRows(currentDragState.rowCount);
                        }
                    } else {
                        // 行を追加
                        if (currentDragState.rowCount > 0) {
                            addRows(currentDragState.rowCount);
                        }
                    }
                } else if (currentDragState.type === 'column') {
                    if (currentDragState.isDelete) {
                        // 列を削除
                        if (currentDragState.columnCount > 0) {
                            deleteColumns(currentDragState.columnCount);
                        }
                    } else {
                        // 列を追加
                        if (currentDragState.columnCount > 0) {
                            addColumns(currentDragState.columnCount);
                        }
                    }
                }
                
                // ドラッグ状態をリセット
                setDragState({
                    isDragging: false,
                    type: null,
                    startY: 0,
                    startX: 0,
                    currentY: 0,
                    currentX: 0,
                    rowCount: 0,
                    columnCount: 0,
                    isDelete: false
                });
                
                // グローバルのマウスイベントを削除
                document.removeEventListener('mousemove', handleDragMove);
                document.removeEventListener('mouseup', handleDragEnd);
            };
            
            // ドラッグプレビューのスタイルを計算
            const getDragPreviewStyle = () => {
                if (!dragState.isDragging) return { display: 'none' };
                
                if (dragState.type === 'row') {
                    if (dragState.isDelete) {
                        // 削除プレビュー（テーブルの下部から上に向かって）
                        const tableRect = tableContainerRef.current.getBoundingClientRect();
                        
                        return {
                            left: tableRect.left,
                            bottom: tableRect.bottom - 20, // 行追加ゾーンの高さを除く
                            width: tableRect.width,
                            height: dragState.rowCount * 20,
                            top: 'auto'
                        };
                    } else {
                        // 追加プレビュー
                        const tableRect = tableContainerRef.current.getBoundingClientRect();
                        const rowZoneRect = rowZoneRef.current.getBoundingClientRect();
                        
                        return {
                            left: tableRect.left,
                            top: rowZoneRect.bottom,
                            width: tableRect.width,
                            height: dragState.rowCount * 20
                        };
                    }
                } else if (dragState.type === 'column') {
                    if (dragState.isDelete) {
                        // 削除プレビュー（テーブルの右端から左に向かって）
                        const tableRect = tableContainerRef.current.getBoundingClientRect();
                        
                        return {
                            right: tableRect.right,
                            top: tableRect.top,
                            width: dragState.columnCount * 20,
                            height: tableRect.height - 20, // 行追加ゾーンの高さを除く
                            left: 'auto'
                        };
                    } else {
                        // 追加プレビュー
                        const tableRect = tableContainerRef.current.getBoundingClientRect();
                        const columnZoneRect = columnZoneRef.current.getBoundingClientRect();
                        
                        return {
                            left: columnZoneRect.right,
                            top: tableRect.top,
                            width: dragState.columnCount * 20,
                            height: tableRect.height - 20 // 行追加ゾーンの高さを除く
                        };
                    }
                }
                
                return { display: 'none' };
            };
            
            // ドラッグプレビューテキストのスタイルを計算
            const getDragPreviewTextStyle = () => {
                if (!dragState.isDragging) return { display: 'none' };
                
                return {
                    left: dragState.currentX + 10,
                    top: dragState.currentY + 10
                };
            };
            
            // ドラッグプレビューテキストを取得
            const getDragPreviewText = () => {
                if (dragState.type === 'row') {
                    if (dragState.isDelete) {
                        return `${dragState.rowCount}行削除`;
                    } else {
                        return `${dragState.rowCount}行追加`;
                    }
                } else if (dragState.type === 'column') {
                    if (dragState.isDelete) {
                        return `${dragState.columnCount}列削除`;
                    } else {
                        return `${dragState.columnCount}列追加`;
                    }
                }
                return '';
            };

            return (
                <div>
                    <div className="controls">
                        <button onClick={saveTable}>保存</button>
                        <button 
                            className="undo-button" 
                            onClick={undo} 
                            disabled={history.length === 0}
                            title={history.length > 0 ? `元に戻す: ${history[history.length-1].action}` : '元に戻す操作はありません'}
                        >
                            元に戻す
                        </button>
                    </div>
                    
                    <div className="table-container" ref={tableContainerRef}>
                        <table ref={tableRef}>
                            <thead>
                                <tr>
                                    {tableData.headers.map((header, index) => (
                                        <th key={`header-${index}`}>
                                            <EditableCell 
                                                content={header} 
                                                rowIndex={-1} 
                                                colIndex={index} 
                                            />
                                        </th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {tableData.rows.map((row, rowIndex) => (
                                    <tr key={`row-${rowIndex}`}>
                                        {row.map((cell, cellIndex) => (
                                            <td key={`cell-${rowIndex}-${cellIndex}`}>
                                                <EditableCell 
                                                    content={cell} 
                                                    rowIndex={rowIndex} 
                                                    colIndex={cellIndex} 
                                                />
                                            </td>
                                        ))}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                        
                        {/* 選択範囲の表示 */}
                        {selectionArea && (
                            <div 
                                className="selection-area"
                                style={{
                                    left: selectionArea.left,
                                    top: selectionArea.top,
                                    width: selectionArea.width,
                                    height: selectionArea.height
                                }}
                            ></div>
                        )}
                        
                        {/* 行追加ゾーン */}
                        <div 
                            ref={rowZoneRef}
                            className="add-row-zone"
                            onMouseDown={(e) => handleDragStart(e, 'row')}
                            title="ドラッグして行を追加/削除"
                        >
                            + 行を追加/削除
                        </div>
                        
                        {/* 列追加ゾーン */}
                        <div 
                            ref={columnZoneRef}
                            className="add-column-zone"
                            onMouseDown={(e) => handleDragStart(e, 'column')}
                            title="ドラッグして列を追加/削除"
                        >
                            + 列を追加/削除
                        </div>
                        
                        {/* ドラッグプレビュー */}
                        {dragState.isDragging && (
                            <>
                                <div 
                                    className={`drag-preview ${dragState.isDelete ? 'delete' : ''}`}
                                    style={getDragPreviewStyle()}
                                ></div>
                                <div 
                                    className={`drag-preview-text ${dragState.isDelete ? 'delete' : ''}`}
                                    style={getDragPreviewTextStyle()}
                                >
                                    {getDragPreviewText()}
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        // Reactコンポーネントをレンダリング
        ReactDOM.render(
            <TableEditor />,
            document.getElementById('root')
        );
        
        // 初期化完了のログ
        console.log('テーブルエディタが初期化されました', {
            headers: initialTableData.headers.length,
            rows: initialTableData.rows.length
        });
        
        // メッセージハンドラを登録
        window.addEventListener('message', event => {
            const message = event.data;
            console.log('VS Codeからメッセージを受信しました', message);
        });
    </script>
</body>
</html> 